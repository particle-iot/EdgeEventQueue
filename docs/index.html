<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EdgeEventQueue: EdgeEventQueue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EdgeEventQueue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <em>Store and forward publishing queue helper for Tracker Edge and Monitor Edge</em></p>
<ul>
<li>Repository: <a href="https://github.com/particle-iot/EdgeEventQueue">https://github.com/particle-iot/EdgeEventQueue</a></li>
<li>License: Apache 2 (free for use in open or closed-source projects, including commercial projects)</li>
<li><a href="https://particle-iot.github.io/EdgeEventQueue/index.html">Browseable API docs</a></li>
</ul>
<p>This library is intended to be used with Tracker Edge or Monitor Edge for implementing custom store and forward queueing. Because its requires the functions of your Edge software, there are no library examples in this repository as they wouldn't be able to be compiled successfully.</p>
<p>For more information about store and forward, see the <a href="https://docs.particle.io/firmware/tracker-edge/sotre-and-forward/">Particle docs</a>.</p>
<h1>Setup</h1>
<h2>Tracker Edge</h2>
<ul>
<li>Add the <a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a> library to your Tracker Edge product, typically using <b>Particle: Install Library</b> in Particle Workbench.</li>
<li>Add the include file:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;EdgeEventQueue.h&quot;</span></div>
</div><!-- fragment --><ul>
<li>Add a global variable for your queue, typically in main.cpp. You will typically one have one, but you can have multiple queues.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_class" href="class_edge_event_queue.html">EdgeEventQueue</a> privateEventQueue;</div>
<div class="ttc" id="aclass_edge_event_queue_html"><div class="ttname"><a href="class_edge_event_queue.html">EdgeEventQueue</a></div><div class="ttdoc">Class for managing a private queue of events on the flash file system.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueue.h:38</div></div>
</div><!-- fragment --><ul>
<li>Initialize the library from <code>setup()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#a0df450dca3fe69e68e4cc1543ba7ef3e">withSizeLimit</a>(50 * 1024)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#a72ff93ca8fa32609fd5535968725a4d8">withQueuePath</a>(<span class="stringliteral">&quot;/usr/testq&quot;</span>)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f">setup</a>();</div>
<div class="ttc" id="aclass_edge_event_queue_html_a0df450dca3fe69e68e4cc1543ba7ef3e"><div class="ttname"><a href="class_edge_event_queue.html#a0df450dca3fe69e68e4cc1543ba7ef3e">EdgeEventQueue::withSizeLimit</a></div><div class="ttdeci">EdgeEventQueue &amp; withSizeLimit(size_t sizeLimit)</div><div class="ttdoc">Set the disk queue size limit (in bytes). Default is 0 (not limited).</div><div class="ttdef"><b>Definition:</b> EdgeEventQueue.h:98</div></div>
<div class="ttc" id="aclass_edge_event_queue_html_a72ff93ca8fa32609fd5535968725a4d8"><div class="ttname"><a href="class_edge_event_queue.html#a72ff93ca8fa32609fd5535968725a4d8">EdgeEventQueue::withQueuePath</a></div><div class="ttdeci">EdgeEventQueue &amp; withQueuePath(const char *path)</div><div class="ttdoc">Sets the queue path. Default is &quot;/usr/privateq&quot;. Typically put in &quot;/usr/&quot; directory.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueue.h:116</div></div>
<div class="ttc" id="aclass_edge_event_queue_html_aaf0fd0cda2a1a4d62c2f969fc13dd65f"><div class="ttname"><a href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f">EdgeEventQueue::setup</a></div><div class="ttdeci">int setup()</div><div class="ttdoc">Call during setup(), the main application setup function.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueue.cpp:15</div></div>
</div><!-- fragment --><ul>
<li>Make sure you provide time to handle the queue by adding a call to <code>loop()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue.<a class="code hl_function" href="class_edge_event_queue.html#a6eaa41eebdcbf9f20b9d6d0bbd83b29b">loop</a>();</div>
<div class="ttc" id="aclass_edge_event_queue_html_a6eaa41eebdcbf9f20b9d6d0bbd83b29b"><div class="ttname"><a href="class_edge_event_queue.html#a6eaa41eebdcbf9f20b9d6d0bbd83b29b">EdgeEventQueue::loop</a></div><div class="ttdeci">void loop()</div><div class="ttdoc">Call during loop(), the main application loop function.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueue.cpp:21</div></div>
</div><!-- fragment --><h2>Monitor Edge</h2>
<ul>
<li>Add the <a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a> library to your Monitor Edge product, typically using <b>Particle: Install Library</b> in Particle Workbench.</li>
<li>Add the include file:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;EdgeEventQueue.h&quot;</span></div>
</div><!-- fragment --><ul>
<li>Add a global variable for your queue, typically in user_setup.cpp. You will typically one have one, but you can have multiple queues.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_class" href="class_edge_event_queue.html">EdgeEventQueue</a> privateEventQueue;</div>
</div><!-- fragment --><ul>
<li>Initialize the library from <code>user_init()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#a0df450dca3fe69e68e4cc1543ba7ef3e">withSizeLimit</a>(50 * 1024)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#a72ff93ca8fa32609fd5535968725a4d8">withQueuePath</a>(<span class="stringliteral">&quot;/usr/testq&quot;</span>)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f">setup</a>();</div>
</div><!-- fragment --><ul>
<li>Make sure you provide time to handle the queue by adding a call to <code>user_loop()</code>:</li>
</ul>
<div class="fragment"><div class="line">privateEventQueue.<a class="code hl_function" href="class_edge_event_queue.html#a6eaa41eebdcbf9f20b9d6d0bbd83b29b">loop</a>();</div>
</div><!-- fragment --><h2>Setup options</h2>
<p>At minimum you will probably want to set a queue path and call setup, as in the examples above. You chain together as many of the <code>withXXX()</code> options you want, then finally call <code>.setup()</code> to complete the setup.</p>
<div class="fragment"><div class="line">privateEventQueue</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#a72ff93ca8fa32609fd5535968725a4d8">withQueuePath</a>(<span class="stringliteral">&quot;/usr/testq&quot;</span>)</div>
<div class="line">    .<a class="code hl_function" href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f">setup</a>();</div>
</div><!-- fragment --><h3>withPriority</h3>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE</span></div>
<div class="line"><a class="code hl_class" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;withPriority(<span class="keywordtype">size_t</span> priority)</div>
</div><!-- fragment --><ul>
<li>priority 0 or 1. 0 is the high priority queue and 1 is the normal priority queue. Location publishes use the normal queue, 1. The default is 1.</li>
</ul>
<h3>withPublishFlags</h3>
<p>Since <code>PRIVATE</code> is always used now (there is no <code>PUBLIC</code>), the only flag that applies now is <code>NO_ACK</code>, however you will rarely use this with queued events.</p>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE</span></div>
<div class="line"><a class="code hl_class" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;withPublishFlags(PublishFlags flags)</div>
</div><!-- fragment --><h3>withSizeLimit</h3>
<p>Set the size limit in bytes. Default is unlimited (0). There is no guarantee you will be able to save the limit you specify as the space is not reserved, but it is treated as a maximum.</p>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE</span></div>
<div class="line"><a class="code hl_class" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;withSizeLimit(<span class="keywordtype">size_t</span> sizeLimit)</div>
</div><!-- fragment --><h3>withDiskQueuePolicy</h3>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE</span></div>
<div class="line"><a class="code hl_class" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;withDiskQueuePolicy(DiskQueuePolicy policy)</div>
</div><!-- fragment --><ul>
<li>policy DiskQueuePolicy::FifoDeleteOld (default) or DiskQueuePolicy::FifoDeleteNew</li>
</ul>
<h3>withQueuePath</h3>
<p>Set the directory path in the flash file system to store the queue files. Each event is stored in a separate file in the queue directory. Each queue must have its own separate directory.</p>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE</span></div>
<div class="line"><a class="code hl_class" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;withQueuePath(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
</div><!-- fragment --><ul>
<li>path Typically put in "/usr/" directory. Does not need to exist; will be created if it does not exist.</li>
</ul>
<h1>Using the library</h1>
<h2>Publishing using the queue</h2>
<p>To queue the data on the flash file system, use the <code>publish()</code> method.</p>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE</span></div>
<div class="line"><span class="keywordtype">int</span> publish(<span class="keyword">const</span> <span class="keywordtype">char</span> *eventName, <span class="keyword">const</span> <span class="keywordtype">char</span> *eventData);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// EXAMPLE</span></div>
<div class="line">privateEventQueue.<a class="code hl_function" href="class_edge_event_queue.html#a6f0c9dde3097de3e6cc35cbd359a0435">publish</a>(<span class="stringliteral">&quot;eventQueueTest&quot;</span>, eventData);</div>
<div class="ttc" id="aclass_edge_event_queue_html_a6f0c9dde3097de3e6cc35cbd359a0435"><div class="ttname"><a href="class_edge_event_queue.html#a6f0c9dde3097de3e6cc35cbd359a0435">EdgeEventQueue::publish</a></div><div class="ttdeci">int publish(const char *eventName, const char *eventData)</div><div class="ttdoc">Add an event to the publish queue on the flash file system.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueue.cpp:85</div></div>
</div><!-- fragment --><p>It returns 0 on success, or a non-zero error code. You will get a success result even if offline, as long as the event can be enqueued.</p>
<h2>Publishing without queueing</h2>
<p>Sometimes you will want to publish an event without using the queue, because the event is temporal and historical data is not useful if the device is currently offline.</p>
<p>To do this, use <code><a class="el" href="class_edge_event_queue.html#a6eb7839f59f5cff10b1f5c8dd8c4d409" title="Publishes an event using the cloud service without using the disk queue.">EdgeEventQueue::cloudServicePublish</a></code>, which takes an eventName and eventData.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_edge_event_queue.html#a6eb7839f59f5cff10b1f5c8dd8c4d409">EdgeEventQueue::cloudServicePublish</a>(<span class="stringliteral">&quot;eventQueueTest&quot;</span>, eventData);</div>
<div class="ttc" id="aclass_edge_event_queue_html_a6eb7839f59f5cff10b1f5c8dd8c4d409"><div class="ttname"><a href="class_edge_event_queue.html#a6eb7839f59f5cff10b1f5c8dd8c4d409">EdgeEventQueue::cloudServicePublish</a></div><div class="ttdeci">static int cloudServicePublish(const char *eventName, const char *eventData, PublishFlags publishFlags={}, size_t priority=0, std::function&lt; int(CloudServiceStatus)&gt; cb=0)</div><div class="ttdoc">Publishes an event using the cloud service without using the disk queue.</div><div class="ttdef"><b>Definition:</b> EdgeEventQueue.cpp:119</div></div>
</div><!-- fragment --><p>This is preferable to directly using Particle.publish because it will interleave the emptying of the queue with sending your non-queued message and will not exceed the publish rate limit.</p>
<p>The full API is:</p>
<div class="fragment"><div class="line"><span class="comment">// PROTOTYPE - EdgeEventQueue</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> cloudServicePublish(<span class="keyword">const</span> <span class="keywordtype">char</span> *eventName, <span class="keyword">const</span> <span class="keywordtype">char</span> *eventData, PublishFlags publishFlags = {}, <span class="keywordtype">size_t</span> priority = 0, std::function&lt;int(CloudServiceStatus)&gt; cb = 0);</div>
</div><!-- fragment --><ul>
<li><code>eventName</code> The event name, as is used in <code>Particle.publish</code>.</li>
<li><code>eventData</code> The event data, as is used in <code>Particle.publish</code>.</li>
<li><code>publishFlags</code> Publish flags, as is used in Particle.publish. This is optional, and if omitted the default flags are used.</li>
<li><code>priority</code> 0 or 1. 0 is the default queue and 1 is the low priority queue.</li>
<li><code>cb</code> Callback function to be called on successful completion or error. Optional. Not called if an immediate error results in a non-zero result code; callback is only called if the return value is 0.</li>
<li>Returns <code>int</code> 0 on success or a non-zero error code</li>
</ul>
<p>The callback function has this prototype:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> callback(CloudServiceStatus status)</div>
</div><!-- fragment --><ul>
<li><code>status</code> is <code>particle::Error::NONE</code> (0) or an system error code on error</li>
</ul>
<p>Callback is a std::function so you can pass a lambda, which allows you to pass additional data via capture variables, or call a C++ class method and instance easily.</p>
<p>The eventName and eventValue are copied and do not need to remain valid until the callback is called. Once the cloudServicePublish call returns, the variables can go out of scope, so it's safe for them to be local variables on the stack.</p>
<p>Using cloudServicePublish interleaves your event with others in the system in a queue in RAM. The queue is finite in size (currently 8 elements per priority queue) and if the queue is full, -EBUSY (-16) is returned.</p>
<p>Note that this function does not use the disk queue! It's a low-level function used by the publish method in this class, or you can use it for your own purposes if you want to publish events that are not saved to disk if the device is currently offline. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
