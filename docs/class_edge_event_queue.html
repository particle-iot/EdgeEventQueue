<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EdgeEventQueue: EdgeEventQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EdgeEventQueue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">EdgeEventQueue Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for managing a private queue of events on the flash file system.  
 <a href="class_edge_event_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_edge_event_queue_8h_source.html">EdgeEventQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43ec1d49eaf3a0ba274271b9a622d28e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a43ec1d49eaf3a0ba274271b9a622d28e">EdgeEventQueue</a> ()</td></tr>
<tr class="memdesc:a43ec1d49eaf3a0ba274271b9a622d28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a43ec1d49eaf3a0ba274271b9a622d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dec2f5f50ce5847050c3472cfe24e9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a52dec2f5f50ce5847050c3472cfe24e9">~EdgeEventQueue</a> ()</td></tr>
<tr class="memdesc:a52dec2f5f50ce5847050c3472cfe24e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a52dec2f5f50ce5847050c3472cfe24e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0fd0cda2a1a4d62c2f969fc13dd65f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f">setup</a> ()</td></tr>
<tr class="memdesc:aaf0fd0cda2a1a4d62c2f969fc13dd65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call during <a class="el" href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f" title="Call during setup(), the main application setup function.">setup()</a>, the main application setup function.  <br /></td></tr>
<tr class="separator:aaf0fd0cda2a1a4d62c2f969fc13dd65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaa41eebdcbf9f20b9d6d0bbd83b29b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a6eaa41eebdcbf9f20b9d6d0bbd83b29b">loop</a> ()</td></tr>
<tr class="memdesc:a6eaa41eebdcbf9f20b9d6d0bbd83b29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call during <a class="el" href="class_edge_event_queue.html#a6eaa41eebdcbf9f20b9d6d0bbd83b29b" title="Call during loop(), the main application loop function.">loop()</a>, the main application loop function.  <br /></td></tr>
<tr class="separator:a6eaa41eebdcbf9f20b9d6d0bbd83b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7f7c566c644ea2c733604eeef96598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a6b7f7c566c644ea2c733604eeef96598">withPriority</a> (size_t priority)</td></tr>
<tr class="memdesc:a6b7f7c566c644ea2c733604eeef96598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the priority to use for publishing. Default is 1 (normal).  <br /></td></tr>
<tr class="separator:a6b7f7c566c644ea2c733604eeef96598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395fadf76be72e581577a6741ebb1172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a395fadf76be72e581577a6741ebb1172">withPublishFlags</a> (PublishFlags flags)</td></tr>
<tr class="memdesc:a395fadf76be72e581577a6741ebb1172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the publish flags such as NO_ACK.  <br /></td></tr>
<tr class="separator:a395fadf76be72e581577a6741ebb1172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df450dca3fe69e68e4cc1543ba7ef3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a0df450dca3fe69e68e4cc1543ba7ef3e">withSizeLimit</a> (size_t sizeLimit)</td></tr>
<tr class="memdesc:a0df450dca3fe69e68e4cc1543ba7ef3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the disk queue size limit (in bytes). Default is 0 (not limited).  <br /></td></tr>
<tr class="separator:a0df450dca3fe69e68e4cc1543ba7ef3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354965ef6382a30d6c2f1c558755f7b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a354965ef6382a30d6c2f1c558755f7b9">withDiskQueuePolicy</a> (DiskQueuePolicy policy)</td></tr>
<tr class="memdesc:a354965ef6382a30d6c2f1c558755f7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the disk queue policy for deleting events when the queue is full.  <br /></td></tr>
<tr class="separator:a354965ef6382a30d6c2f1c558755f7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ff93ca8fa32609fd5535968725a4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a72ff93ca8fa32609fd5535968725a4d8">withQueuePath</a> (const char *path)</td></tr>
<tr class="memdesc:a72ff93ca8fa32609fd5535968725a4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the queue path. Default is "/usr/privateq". Typically put in "/usr/" directory.  <br /></td></tr>
<tr class="separator:a72ff93ca8fa32609fd5535968725a4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0c9dde3097de3e6cc35cbd359a0435"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a6f0c9dde3097de3e6cc35cbd359a0435">publish</a> (const char *eventName, const char *eventData)</td></tr>
<tr class="memdesc:a6f0c9dde3097de3e6cc35cbd359a0435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event to the publish queue on the flash file system.  <br /></td></tr>
<tr class="separator:a6f0c9dde3097de3e6cc35cbd359a0435"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6eb7839f59f5cff10b1f5c8dd8c4d409"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_event_queue.html#a6eb7839f59f5cff10b1f5c8dd8c4d409">cloudServicePublish</a> (const char *eventName, const char *eventData, PublishFlags publishFlags={}, size_t priority=0, std::function&lt; int(CloudServiceStatus)&gt; cb=0)</td></tr>
<tr class="memdesc:a6eb7839f59f5cff10b1f5c8dd8c4d409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes an event using the cloud service without using the disk queue.  <br /></td></tr>
<tr class="separator:a6eb7839f59f5cff10b1f5c8dd8c4d409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for managing a private queue of events on the flash file system. </p>
<p>The CloudService has a different prototype on Tracker Edge and Monitor Edge. These defines can be used to determine which Edge firmware you are using. This class defines a common API so you don't have to worry about it from your code. </p>
<p>Only available on devices using TrackerEdge or MonitorEdge, as it utilizes the DiskQueue and CloudService classes.</p>
<p>When metering out events to stay within the rate limit, this interleaves your private events and the system events so you won't exceed the rate limit.</p>
<p>A queue size limit specified in this class is independent of the one set in the cloud configuration. There is no checking done to make sure there's enough disk space available across all queues. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43ec1d49eaf3a0ba274271b9a622d28e" name="a43ec1d49eaf3a0ba274271b9a622d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ec1d49eaf3a0ba274271b9a622d28e">&#9670;&#160;</a></span>EdgeEventQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeEventQueue::EdgeEventQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Construct one of these object for each queue. Often there will only be one, but the code supports multiple queues. It is typically constructed as a global object. </p>

</div>
</div>
<a id="a52dec2f5f50ce5847050c3472cfe24e9" name="a52dec2f5f50ce5847050c3472cfe24e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dec2f5f50ce5847050c3472cfe24e9">&#9670;&#160;</a></span>~EdgeEventQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeEventQueue::~EdgeEventQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This is typically not used as the object is typically instantiated as a global object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6eb7839f59f5cff10b1f5c8dd8c4d409" name="a6eb7839f59f5cff10b1f5c8dd8c4d409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb7839f59f5cff10b1f5c8dd8c4d409">&#9670;&#160;</a></span>cloudServicePublish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int EdgeEventQueue::cloudServicePublish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>publishFlags</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(CloudServiceStatus)&gt;&#160;</td>
          <td class="paramname"><em>cb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publishes an event using the cloud service without using the disk queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The event name, as is used in Particle.publish.</td></tr>
    <tr><td class="paramname">eventData</td><td>The event data, as is used in Particle.publish</td></tr>
    <tr><td class="paramname">publishFlags</td><td>Publish flags, as is used in Particle.publish. This is optional, and if omitted the default flags are used.</td></tr>
    <tr><td class="paramname">priority</td><td>0 or 1. 0 is the high priority queue and 1 is the normal priority queue. Location publishes use the normal queue, 1.</td></tr>
    <tr><td class="paramname">cb</td><td>Callback function to be called on successful completion or error. Optional. Not called if an immediate error results in a non-zero result code; callback is only called if the return value is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success or a non-zero error code</dd></dl>
<p>The callback function has this prototype:</p>
<p>int callback(CloudServiceStatus status)</p>
<ul>
<li><code>status</code> is <code>particle::Error::NONE</code> (0) or an system error code on error</li>
</ul>
<p>It is a std::function so you can pass a lambda, which allows you to pass additional data via capture variables, or call a C++ class method and instance easily.</p>
<p>The eventName and eventValue are copied and do not need to remain valid until the callback is called. Once the cloudServicePublish call returns, the variables can go out of scope, so it's safe for them to be local variables on the stack.</p>
<p>Using cloudServicePublish interleaves your event with others in the system in a queue in RAM. The queue is finite in size (currently 8 elements per priority queue) and if the queue is full, -EBUSY (-16) is returned.</p>
<p>Note that this function does not use the disk queue! It's a low-level function used by the publish method in this class, or you can use it for your own purposes if you want to publish events that are not saved to disk if the device is currently offline. </p>

</div>
</div>
<a id="a6eaa41eebdcbf9f20b9d6d0bbd83b29b" name="a6eaa41eebdcbf9f20b9d6d0bbd83b29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaa41eebdcbf9f20b9d6d0bbd83b29b">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EdgeEventQueue::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call during <a class="el" href="class_edge_event_queue.html#a6eaa41eebdcbf9f20b9d6d0bbd83b29b" title="Call during loop(), the main application loop function.">loop()</a>, the main application loop function. </p>
<p>Typically used as: EdgeEventQueue::instance().<a class="el" href="class_edge_event_queue.html#a6eaa41eebdcbf9f20b9d6d0bbd83b29b" title="Call during loop(), the main application loop function.">loop()</a>; </p>

</div>
</div>
<a id="a6f0c9dde3097de3e6cc35cbd359a0435" name="a6f0c9dde3097de3e6cc35cbd359a0435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0c9dde3097de3e6cc35cbd359a0435">&#9670;&#160;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EdgeEventQueue::publish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event to the publish queue on the flash file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The event name, as is used in Particle.publish</td></tr>
    <tr><td class="paramname">eventData</td><td>The event data, as is used in Particle.publish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success or a non-zero error code</dd></dl>
<p>The eventName and eventValue are copied and do not need to remain valid until the callback is called. Once the publish call returns, the variables can go out of scope, so it's safe for them to be local variables on the stack. </p>

</div>
</div>
<a id="aaf0fd0cda2a1a4d62c2f969fc13dd65f" name="aaf0fd0cda2a1a4d62c2f969fc13dd65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0fd0cda2a1a4d62c2f969fc13dd65f">&#9670;&#160;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EdgeEventQueue::setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call during <a class="el" href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f" title="Call during setup(), the main application setup function.">setup()</a>, the main application setup function. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a non-zero error code</dd></dl>
<p>Typically used as: EdgeEventQueue::instance().<a class="el" href="class_edge_event_queue.html#aaf0fd0cda2a1a4d62c2f969fc13dd65f" title="Call during setup(), the main application setup function.">setup()</a>;</p>
<p>Call the withXXX() methods to set configuration parameters before setup! </p>

</div>
</div>
<a id="a354965ef6382a30d6c2f1c558755f7b9" name="a354965ef6382a30d6c2f1c558755f7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354965ef6382a30d6c2f1c558755f7b9">&#9670;&#160;</a></span>withDiskQueuePolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp; EdgeEventQueue::withDiskQueuePolicy </td>
          <td>(</td>
          <td class="paramtype">DiskQueuePolicy&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the disk queue policy for deleting events when the queue is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>DiskQueuePolicy::FifoDeleteOld (default) or DiskQueuePolicy::FifoDeleteNew</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a>&amp; Reference to this object to chain, fluent-style </dd></dl>

</div>
</div>
<a id="a6b7f7c566c644ea2c733604eeef96598" name="a6b7f7c566c644ea2c733604eeef96598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f7c566c644ea2c733604eeef96598">&#9670;&#160;</a></span>withPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp; EdgeEventQueue::withPriority </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the priority to use for publishing. Default is 1 (normal). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>0 or 1. 0 is the high priority queue and 1 is the normal priority queue. Location publishes use the normal queue, 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a>&amp; Reference to this object to chain, fluent-style </dd></dl>

</div>
</div>
<a id="a395fadf76be72e581577a6741ebb1172" name="a395fadf76be72e581577a6741ebb1172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395fadf76be72e581577a6741ebb1172">&#9670;&#160;</a></span>withPublishFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp; EdgeEventQueue::withPublishFlags </td>
          <td>(</td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the publish flags such as NO_ACK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a>&amp; </dd></dl>

</div>
</div>
<a id="a72ff93ca8fa32609fd5535968725a4d8" name="a72ff93ca8fa32609fd5535968725a4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ff93ca8fa32609fd5535968725a4d8">&#9670;&#160;</a></span>withQueuePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp; EdgeEventQueue::withQueuePath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the queue path. Default is "/usr/privateq". Typically put in "/usr/" directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Typically put in "/usr/" directory. Does not need to exist; will be created if it does not exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a>&amp; Reference to this object to chain, fluent-style </dd></dl>

</div>
</div>
<a id="a0df450dca3fe69e68e4cc1543ba7ef3e" name="a0df450dca3fe69e68e4cc1543ba7ef3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df450dca3fe69e68e4cc1543ba7ef3e">&#9670;&#160;</a></span>withSizeLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge_event_queue.html">EdgeEventQueue</a> &amp; EdgeEventQueue::withSizeLimit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the disk queue size limit (in bytes). Default is 0 (not limited). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_edge_event_queue.html" title="Class for managing a private queue of events on the flash file system.">EdgeEventQueue</a>&amp; Reference to this object to chain, fluent-style </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_edge_event_queue_8h_source.html">EdgeEventQueue.h</a></li>
<li>src/EdgeEventQueue.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
